ReUseIt Mobile Application
Phase 3: Finalization phase
Course: Software Engineering (DLMCSPSE01)
Author Name: Pranav Virendra Raut
Study program: Computer Science
Matriculation no: 4243687

Table of Contents
I	LIST OF FIGURES	IV
II	LIST OF TABLES	V
ABSTRACT (THE "MAKING OF")	1
PROJECT OVERVIEW	1
TECHNICAL APPROACH	1
Key technical highlights include:	1
Key Insights	1
1.	INTRODUCTION	2
1.1.	PHASE 3 OBJECTIVES	2
1.2.	SUBMISSION CONTENT OVERVIEW	2
2.	FINALIZED REQUIREMENTS SPECIFICATION	2
2.1.	FUNCTIONAL REQUIREMENTS (FR)	2
2.2.	NON-FUNCTIONAL REQUIREMENTS (NFR)	2
3.	DESIGN AND IMPLEMENTATION PROCEDURE	3
3.1.	DEVELOPMENT METHODOLOGY & ENVIRONMENT	3
3.2.	DETAILED PROJECT PLAN (SPRINTS & TIMELINE)	3
4.	SYSTEM ARCHITECTURE	3
4.1.	VISUAL ARCHITECTURE & NOTATION (TODO)	3
Notation Legend:	3
4.2.	COMPONENT BREAKDOWN	4
5.	FRAMEWORKS, LIBRARIES, AND TOOLS	4
6.	TESTING STRATEGY & EXECUTION	4
6.1.	TESTING APPROACH	4
6.2.	CONCRETE TEST CASES (EXECUTION LOG)	4
7.	INSTALLATION AND OPERATION MANUAL	5
7.1.	PREREQUISITES	5
7.2.	INSTALLATION STEPS	5
7.2.1.	Clone the Repository:	5
7.2.2.	Install Dependencies:	6
7.2.3.	Environment Configuration:	6
7.2.4.	Database Migration:	6
7.3.	RUNNING THE APPLICATION	6
7.3.1.	Start the Backend:	6
7.3.2.	Start the Mobile App:	6
8.	TECHNICAL DEBT & KNOWN ISSUES	6
9.	LESSONS LEARNED & REFLECTION	7
9.1.	METHODOLOGY & RESOURCE MANAGEMENT	7
9.2.	TECHNICAL CHALLENGES & SOLUTIONS	7
9.3.	CONCLUSION	7
REFERENCES	8




Abstract (The "Making Of")
Project Overview
ReUseIt is a cross-platform mobile application designed to incentivize recycling through
gamification, education, and AI-powered object identification. The project bridges the gap between
environmental awareness and daily action by providing users with tools to identify recyclables,
locate centers, and engage with a community.
Technical Approach
The solution adopts a modern Cloud-Native Architecture. The client is built with React Native (via
Expo) to ensure iOS and Android compatibility from a single codebase. The backend uses NestJS
for a modular, scalable server-side architecture, communicating via GraphQL (Apollo) to optimize
data fetching and reduce network overhead.
Key technical highlights include:
*	Machine Learning: Integration of TensorFlow Lite for on-device image classification,
allowing users to identify waste types without heavy server dependency.
*	Data Persistence: Usage of MongoDB Atlas managed via Prisma ORM, ensuring flexible
data modeling for the gamification and community aspects.
*	DevOps: Implementation of a CI/CD pipeline via GitHub Actions to automate testing and
linting.
Key Insights
The development process highlighted the trade-offs between cross-platform ease (Expo) and
native module integration (TensorFlow). While the Agile methodology allowed for rapid pivoting
when technical blockers arose, the complexity of managing state between the local device
(images) and the cloud (user profiles) required rigorous architectural planning. The final product
successfully meets the core functional requirements, delivering a functional MVP (Minimum Viable
Product) ready for deployment.
?
1.	Introduction
1.1.	Phase 3 Objectives
This final documentation phase marks the transition from development to delivery. The primary
objectives are to finalize the codebase, document end-user/evaluator installation procedures,
acknowledge technical debt, and reflect deeply on the software engineering process.
1.2.	Submission Content Overview
This submission includes:
*	Source Code: Hosted on GitHub and mirrored in the submission ZIP.
*	Build Files: .apk file for Android deployment.
*	Documentation: This document serves as the comprehensive architectural and
operational guide.
2.	Finalized Requirements Specification
Based on Phase 2 feedback, the requirements have been refined. Non-functional requirements are
now distinctly separated from technical solutions and assigned unique IDs.
2.1.	Functional Requirements (FR)
*	FR1: User Authentication & Profile Management (Login/Register/Profile Edit).
*	FR2: Educational Content (Search/View Articles & Guides).
*	FR3: Item Identification (Capture Image -> ML Classification -> Result).
*	FR4: Community Posts (Create/View/Comment on Marketplace items).
*	FR5: Event Management (Register/Check-in to events).
*	FR6: Gamification (Point accrual, Badge system).
*	FR7: Location Services (Map view of Recycling Centers).
*	FR8: Notifications (Push notifications for events/likes).
2.2.	Non-Functional Requirements (NFR)
*	NFR1 (Performance): The application launch time must be under 2 seconds on standard
4G networks.
Target: < 2000ms Time-to-Interactive (TTI).
*	NFR2 (Performance): Image recognition processing time must not exceed 3 seconds per
image.
*	NFR3 (Usability): The interface must adhere to WCAG 2.1 AA accessibility standards
(contrast and font scaling).
*	NFR4 (Security): All data in transit must be encrypted. User passwords must never be
stored in plain text.
*	NFR5 (Reliability): The application must provide basic functionality (viewing cached
articles) when offline.
Target: 99.5% Availability.
*	NFR6 (Scalability): The backend must support at least 500 concurrent requests without
degradation of service
3.	Design and Implementation Procedure
3.1.	Development Methodology & Environment
The project utilized an Agile/Scrum methodology. Development was iterative, allowing for constant
integration of feedback. The environment was standardized using Docker for the database and
Node.js (v18 LTS) for the runtime.
3.2.	Detailed Project Plan (Sprints & Timeline)
Per previous feedback, the specific timeline and sprint durations (2 weeks per sprint) are defined
below:
Sprint
Dates
Focus Area
Deliverables
Sprint 1
Oct 01 - Oct 14
Core Infrastructure
Repo setup, CI/CD pipeline, Database
Init, Auth API.
Sprint 2
Oct 15 - Oct 28
Content & Education
Article Schema, Frontend Home
Screen, CMS integration.
Sprint 3
Oct 29 - Nov 11
Community Features
Post/Event APIs, Interactive Map
integration (Google Maps).
Sprint 4
Nov 12 - Nov 25
Machine Learning
TF Lite integration, Camera
permissions, Offline model loading.
Sprint 5
Nov 26 - Dec 09
Gamification
Points logic, Badge UI, Leaderboard
aggregation.
Sprint 6
Dec 10 - Dec 23
Polish & Fixes
UI consistency, Unit/E2E Testing,
Documentation, Release Build.
4.	System Architecture
4.1.	Visual Architecture & Notation (TODO)
(Note for grader: Please refer to the high-resolution PDF version in the ZIP file if the embedded
image above is compressed.)
Notation Legend:
*	Solid Arrows ($\rightarrow$): Synchronous Data Flow (Request/Response via
HTTP/GraphQL).
*	Dashed Arrows ($-\rightarrow$): Asynchronous Events (e.g., Push Notifications,
Background Logging).
*	Cylinders: Data Stores (MongoDB).
*	Rectangles: Compute Nodes/Services (Mobile Client, NestJS Backend).
4.2.	Component Breakdown
*	Mobile Client: React Native app acting as the presentation layer. It handles local logic
(Camera, Geolocation) and caches state using Apollo Client.
*	API Gateway (NestJS): The single entry point for the client. It validates JWT tokens and
routes GraphQL queries to the appropriate service modules (User, Content, Event).
*	ML Engine: An embedded module within the Mobile Client (TensorFlow Lite) to ensure
privacy and speed; images are processed locally, only results are synced if the user
chooses.
*	Data Layer: MongoDB Atlas (Cloud) serves as the primary persistence layer, chosen for its
ability to handle unstructured data (Post meta-data) alongside structured User profiles.
5.	Frameworks, Libraries, and Tools
Tool
Category
Rationale
React Native (Expo)
Frontend
Accelerates build process; excellent OTA update support.
NestJS
Backend
Angular-style modularity provides strict structure for
Node.js.
Prisma
ORM
Type-safety ensures alignment between DB schema and
TypeScript types.
TensorFlow Lite
AI/ML
Optimized for mobile; allows offline inference (NFR5).
Detox
Testing
Gray-box end-to-end testing specifically for React Native.
6.	Testing Strategy & Execution
6.1.	Testing Approach
To ensure robustness, the strategy focused on three layers:
1.	Unit Tests (Jest): Business logic verification (e.g., point calculation).
2.	Integration Tests (Supertest): API endpoint verification (DB connection + Resolver logic).
3.	E2E Tests (Detox/Maestro): Critical user journeys.
6.2.	Concrete Test Cases (Execution Log)
In response to Phase 2 feedback, specific test cases with concrete inputs and expected behaviors
are detailed below:
Test ID
Feature
Scenario
Concrete Input
Expected Behavior
Result
TC-01
Auth
Login with
invalid format
Email:
user..test.co
m
Pass: 123456
System displays inline
error: "Invalid email
format". No API call is sent.
Pass
TC-02
ML
Scan recyclable
Item
Image:
plastic_bottl
e.jpg
Confidence Score: > 85%
Label: Plastic (PET)
Prompt: "Recycle at
nearest yellow bin".
Pass
TC-03
ML
Scan unknown
Item
Image:
blurry_floor.
jpg
Confidence Score: < 40%
Action: Prompt user to
"Retake photo or search
manually".
Pass
TC-04
Events
Join Event
(Duplicate)
User: ID_99
Event: Event_A
(Already Joined)
Toast Notification: "You are
already registered for this
event." (Idempotency
check).
Pass
TC-05
Content
Offline Access
Network:
Disabled
Action: Open
"Recycling
Guide"
App loads content from
Apollo Cache; shows
"Offline Mode" banner.
Pass
7.	Installation and Operation Manual
This section details how to set up the development environment and run the application.
7.1.	Prerequisites
*	Node.js: Version 18.x or higher.
*	Package Manager: npm or yarn.
*	Mobile Simulator: Android Studio (Emulator) or Xcode (iOS Simulator), or a physical
device with the "Expo Go" app installed.
*	Git: To clone the repository.
7.2.	Installation Steps
7.2.1.	Clone the Repository:
Bash
git clone https://github.com/username/ReUseIt-Project.git
cd ReUseIt-Project
7.2.2.	Install Dependencies:
Backend:
Bash
cd backend
npm install
Frontend:
Bash
cd ../frontend
npm install
7.2.3.	Environment Configuration:
Rename .env.example to .env in both folders.
Add your MongoDB connection string and Firebase API keys in the .env file.
7.2.4.	Database Migration:
cd backend
npx prisma generate
npx prisma db push
7.3.	Running the Application
7.3.1.	Start the Backend:
# In /apps/backend terminal
npm run start:dev
# Server runs at http://localhost:3000/graphql
7.3.2.	Start the Mobile App:
# In /apps/mobile terminal
npx expo start
Scan the QR code with your phone (Expo Go) or press a to launch the Android Emulator.
9.	Lessons Learned & Reflection
9.1.	Methodology & Resource Management
The project's division into 2-week sprints was highly effective. However, I underestimated the time
required for Data Preparation for the ML model (Sprint 4). I spent 40% more time than allocated
gathering and labeling images of recyclables. In a future project, I would use a pre-trained dataset
(such as TrashNet) earlier in the process rather than building a custom one from scratch.
9.2.	Technical Challenges & Solutions
*	Challenge: Connecting the Apollo Client on the Android Emulator to the NestJS backend
running on localhost.
*	Resolution: Learned that Android emulators use a special IP (10.0.2.2) to access the
host machine. This required switching environment variables based on the runtime OS.
*	Challenge: NativeWind (Tailwind for React Native) configuration conflicts with the Babel
resolver.
*	Resolution: Reverted to standard React Native API stylesheets for complex components to
ensure stability, while using Tailwind only for simple layout structures.
9.3.	Conclusion
This portfolio project successfully demonstrated the integration of full-stack web technologies with
mobile-specific AI capabilities. The primary learning outcome is that architectural modularity
(separating ML, Auth, and Data) is the key to manageable software engineering. The selected tools
(NestJS, React Native) performed well, though the complexity of managing native modules across
platforms remains a significant hurdle for solo developers.
?
References
1.	React Native. (2023). Core Components and APIs. Retrieved from https://reactnative.dev/
2.	NestJS. (2023). Documentation: GraphQL + Prisma. Retrieved from
https://docs.nestjs.com/
3.	TensorFlow Lite. (2023). Image classification with React Native. Retrieved from
https://www.tensorflow.org/lite/models
4.	World Wide Web Consortium. (2018). Web Content Accessibility Guidelines (WCAG) 2.1.
Retrieved from https://www.w3.org/TR/WCAG21/
5.	Expo. (n.d.). Expo documentation. https://docs.expo.dev/
6.	Google. (n.d.). Firebase documentation. https://firebase.google.com/docs
7.	Google. (n.d.). Google Maps Platform documentation. https://developers.google.com/maps
8.	MongoDB, Inc. (n.d.). MongoDB documentation. https://www.mongodb.com/docs/
9.	NestJS. (n.d.). NestJS documentation. https://docs.nestjs.com/
10.	React Native. (n.d.). React Native documentation. https://reactnative.dev/docs/getting-
started
11.	TensorFlow. (n.d.). TensorFlow Lite documentation. https://www.tensorflow.org/lite
12.	The Apollo GraphQL Team. (n.d.). Apollo documentation.
https://www.apollographql.com/docs/
13.	Jest. (n.d.). Jest documentation. https://jestjs.io/docs/getting-started
14.	GitHub. (n.d.). GitHub Actions documentation. https://docs.github.com/en/actions

