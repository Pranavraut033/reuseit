#!/usr/bin/env python
"""Visualize YOLO labels from CSV or .txt files on images.

This script visualizes bounding boxes from:
1. CSV files generated by auto-labeling (contains YOLO's COCO class IDs)
2. YOLO .txt label files in a dataset directory (contains our canonical waste class IDs)

Usage examples:
    # Visualize CSV labels (shows COCO class names like 'bottle', 'person', etc.)
    python visualize_yolo_labels.py --csv yolo_labels.csv --images ../merged_dataset

    # Visualize prepared YOLO dataset labels (shows waste class names)
    python visualize_yolo_labels.py --dataset yolo_dataset --split val

    # Visualize with custom settings
    python visualize_yolo_labels.py --csv yolo_labels.csv --images ../merged_dataset --min-confidence 0.5 --max-images 10 --show
"""

import os
import argparse
import csv
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import cv2
import numpy as np
from rich import print

# Import from local utils
from dataset_utils_yolo import CANONICAL_CLASSES, CLASS_TO_ID

# COCO class names for YOLO detections (YOLOv8 uses COCO by default)
COCO_CLASSES = [
    "person",
    "bicycle",
    "car",
    "motorcycle",
    "airplane",
    "bus",
    "train",
    "truck",
    "boat",
    "traffic light",
    "fire hydrant",
    "stop sign",
    "parking meter",
    "bench",
    "bird",
    "cat",
    "dog",
    "horse",
    "sheep",
    "cow",
    "elephant",
    "bear",
    "zebra",
    "giraffe",
    "backpack",
    "umbrella",
    "handbag",
    "tie",
    "suitcase",
    "frisbee",
    "skis",
    "snowboard",
    "sports ball",
    "kite",
    "baseball bat",
    "baseball glove",
    "skateboard",
    "surfboard",
    "tennis racket",
    "bottle",
    "wine glass",
    "cup",
    "fork",
    "knife",
    "spoon",
    "bowl",
    "banana",
    "apple",
    "sandwich",
    "orange",
    "broccoli",
    "carrot",
    "hot dog",
    "pizza",
    "donut",
    "cake",
    "chair",
    "couch",
    "potted plant",
    "bed",
    "dining table",
    "toilet",
    "tv",
    "laptop",
    "mouse",
    "remote",
    "keyboard",
    "cell phone",
    "microwave",
    "oven",
    "toaster",
    "sink",
    "refrigerator",
    "book",
    "clock",
    "vase",
    "scissors",
    "teddy bear",
    "hair drier",
    "toothbrush",
]


def load_csv_labels(csv_path: str, min_confidence: float = 0.0) -> Dict[str, List[Dict]]:
    """Load YOLO labels from CSV file."""
    detections = {}

    try:
        with open(csv_path, "r") as f:
            reader = csv.DictReader(f)
            for row in reader:
                filename = row["filename"].strip()
                confidence = float(row["confidence"])

                if confidence < min_confidence:
                    continue

                detection = {
                    "x_center": float(row["x_center"]),
                    "y_center": float(row["y_center"]),
                    "width": float(row["width"]),
                    "height": float(row["height"]),
                    "confidence": confidence,
                    "class_id": int(row["class_id"]),
                }

                if filename not in detections:
                    detections[filename] = []
                detections[filename].append(detection)

    except FileNotFoundError:
        print(f"[red]CSV file not found: {csv_path}[/red]")
        return {}
    except Exception as e:
        print(f"[red]Error reading CSV: {e}[/red]")
        return {}

    return detections


def load_txt_labels(labels_dir: str) -> Dict[str, List[Dict]]:
    """Load YOLO labels from .txt files in labels directory."""
    detections = {}

    labels_path = Path(labels_dir)
    if not labels_path.exists():
        print(f"[red]Labels directory not found: {labels_dir}[/red]")
        return {}

    for txt_file in labels_path.glob("*.txt"):
        image_stem = txt_file.stem
        detections[image_stem] = []

        try:
            with open(txt_file, "r") as f:
                for line in f:
                    parts = line.strip().split()
                    if len(parts) != 5:
                        continue

                    class_id, x_center, y_center, width, height = map(float, parts)

                    detection = {
                        "x_center": x_center,
                        "y_center": y_center,
                        "width": width,
                        "height": height,
                        "confidence": 1.0,  # .txt files don't have confidence
                        "class_id": int(class_id),
                    }

                    detections[image_stem].append(detection)

        except Exception as e:
            print(f"[yellow]Error reading {txt_file}: {e}[/yellow]")
            continue

    return detections


def find_image_files(images_dir: str) -> Dict[str, str]:
    """Create mapping from relative path to full image path."""
    mapping = {}
    images_path = Path(images_dir)

    if not images_path.exists():
        print(f"[red]Images directory not found: {images_dir}[/red]")
        return mapping

    for img_path in images_path.rglob("*"):
        if img_path.is_file() and img_path.suffix.lower() in [".jpg", ".jpeg", ".png"]:
            try:
                # Store relative path from images_dir as key
                rel_path = img_path.relative_to(images_path)
                mapping[str(rel_path)] = str(img_path)
            except ValueError:
                # Fallback to just filename if relative_to fails
                mapping[img_path.name] = str(img_path)

    return mapping


def yolo_to_pixels(
    x_center: float, y_center: float, width: float, height: float, img_width: int, img_height: int
) -> Tuple[int, int, int, int]:
    """Convert normalized YOLO coordinates to pixel coordinates."""
    x1 = int((x_center - width / 2) * img_width)
    y1 = int((y_center - height / 2) * img_height)
    x2 = int((x_center + width / 2) * img_width)
    y2 = int((y_center + height / 2) * img_height)

    # Clamp to image boundaries
    x1 = max(0, min(x1, img_width - 1))
    y1 = max(0, min(y1, img_height - 1))
    x2 = max(0, min(x2, img_width - 1))
    y2 = max(0, min(y2, img_height - 1))

    return x1, y1, x2, y2


def draw_bounding_box(
    image: np.ndarray,
    box: Tuple[int, int, int, int],
    label: str,
    color: Tuple[int, int, int] = (0, 255, 0),
    thickness: int = 2,
):
    """Draw bounding box and label on image."""
    x1, y1, x2, y2 = box

    # Draw rectangle
    cv2.rectangle(image, (x1, y1), (x2, y2), color, thickness)

    # Draw label background
    (text_width, text_height), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 1)
    cv2.rectangle(image, (x1, max(0, y1 - text_height - 6)), (x1 + text_width + 6, y1), color, -1)

    # Draw label text
    cv2.putText(
        image,
        label,
        (x1 + 3, y1 - 4),
        cv2.FONT_HERSHEY_SIMPLEX,
        0.6,
        (255, 255, 255),
        1,
        cv2.LINE_AA,
    )


def get_class_color(class_id: int) -> Tuple[int, int, int]:
    """Get color for class visualization."""
    colors = [
        (0, 255, 0),  # Green
        (255, 0, 0),  # Blue
        (0, 0, 255),  # Red
        (255, 255, 0),  # Cyan
        (255, 0, 255),  # Magenta
        (0, 255, 255),  # Yellow
        (128, 128, 0),  # Olive
        (128, 0, 128),  # Purple
    ]
    return colors[class_id % len(colors)]


def visualize_labels(
    detections: Dict[str, List[Dict]],
    image_mapping: Dict[str, str],
    output_dir: str,
    max_images: int = 0,
    show: bool = False,
    use_canonical_classes: bool = False,
):
    """Visualize detections on images."""
    os.makedirs(output_dir, exist_ok=True)

    processed = 0

    for image_stem, dets in detections.items():
        if max_images > 0 and processed >= max_images:
            break

        if image_stem not in image_mapping:
            print(f"[yellow]Image not found: {image_stem}[/yellow]")
            continue

        image_path = image_mapping[image_stem]

        # Load image
        image = cv2.imread(image_path)
        if image is None:
            print(f"[red]Failed to load image: {image_path}[/red]")
            continue

        height, width = image.shape[:2]

        # Draw bounding boxes
        for det in dets:
            box = yolo_to_pixels(
                det["x_center"], det["y_center"], det["width"], det["height"], width, height
            )

            class_id = det["class_id"]
            confidence = det["confidence"]

            # Choose class name based on source
            if use_canonical_classes:
                # Use our canonical waste classes
                if class_id < len(CANONICAL_CLASSES):
                    class_name = CANONICAL_CLASSES[class_id]
                else:
                    class_name = f"class_{class_id}"
            else:
                # Use COCO classes for YOLO detections
                if class_id < len(COCO_CLASSES):
                    class_name = COCO_CLASSES[class_id]
                else:
                    class_name = f"class_{class_id}"

            if confidence < 1.0:
                label = ".2f"
            else:
                label = class_name

            color = get_class_color(class_id)
            draw_bounding_box(image, box, label, color)

        # Save visualized image
        output_path = os.path.join(output_dir, f"{image_stem}_visualized.jpg")
        cv2.imwrite(output_path, image)

        if show:
            cv2.imshow(f"Visualization - {image_stem}", image)
            cv2.waitKey(0)
            cv2.destroyAllWindows()

        processed += 1
        print(f"[green]Processed: {image_stem} ({len(dets)} detections)[/green]")

    print(f"[bold green]Visualization complete! Processed {processed} images.[/bold green]")


def main():
    parser = argparse.ArgumentParser(description="Visualize YOLO labels on images")
    parser.add_argument("--csv", type=str, help="Path to CSV file with YOLO labels")
    parser.add_argument("--dataset", type=str, help="Path to prepared YOLO dataset directory")
    parser.add_argument(
        "--split",
        type=str,
        choices=["train", "val", "test"],
        default="val",
        help="Dataset split to visualize (train/val/test)",
    )
    parser.add_argument("--images", type=str, help="Directory containing images (when using --csv)")
    parser.add_argument("--output", type=str, default="visualized", help="Output directory")
    parser.add_argument(
        "--min-confidence", type=float, default=0.0, help="Minimum confidence threshold"
    )
    parser.add_argument(
        "--max-images", type=int, default=0, help="Maximum number of images to visualize (0=all)"
    )
    parser.add_argument(
        "--show", action="store_true", help="Show images in window during processing"
    )

    args = parser.parse_args()

    # Validate arguments
    if not args.csv and not args.dataset:
        print("[red]Error: Must specify either --csv or --dataset[/red]")
        return

    if args.csv and not args.images:
        print("[red]Error: --images is required when using --csv[/red]")
        return

    # Load detections
    if args.csv:
        print(f"[cyan]Loading labels from CSV: {args.csv}[/cyan]")
        detections = load_csv_labels(args.csv, args.min_confidence)
        image_mapping = find_image_files(args.images)
        use_canonical = False  # CSV contains YOLO's COCO class IDs
    else:
        print(f"[cyan]Loading labels from dataset: {args.dataset} ({args.split} split)[/cyan]")
        labels_dir = os.path.join(args.dataset, "labels", args.split)
        images_dir = os.path.join(args.dataset, "images", args.split)
        detections = load_txt_labels(labels_dir)
        image_mapping = find_image_files(images_dir)
        use_canonical = True  # .txt files contain our canonical class IDs

    if not detections:
        print("[yellow]No detections found to visualize[/yellow]")
        return

    print(f"[cyan]Found {len(detections)} images with labels[/cyan]")
    print(f"[cyan]Found {len(image_mapping)} images in directory[/cyan]")
    print(f"[cyan]Using {'canonical' if use_canonical else 'COCO'} class names[/cyan]")

    # Visualize
    visualize_labels(
        detections, image_mapping, args.output, args.max_images, args.show, use_canonical
    )


if __name__ == "__main__":
    main()
